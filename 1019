#include <cstring>
#include <algorithm>
#include <iostream>

//массивы для хранения координат начала, конца и цвета отрезка
//5000 - максимальное число перекрашиваний
int a[5000], b[5000];
char color[5000];

//массив для всех координат, индекс прохождения
//и массив для отслеживания белых отрезков
int X[10002], sz;
bool white[10001];

int main()
{
    //вводим количество перекрашиваний
    int N;
    std::cin >> N;

    //заполняем первые 2 ячейки начальными координатами отрезка и переносим индекс
    //(Изначально отрезок от 0 до 10^9 покрашен в белый
    X[0] = 0; X[1] = 1000000000;
    sz = 2;

    //Ввод информации о перекрашиваниях и заполнение массивов
    for (int i = 0; i < N; ++i) {
        std::cin >> a[i] >> b[i] >> color[i];
        X[sz] = a[i];
        ++sz;
        X[sz] = b[i];
        ++sz;
    }

    //Сортировка массива всех координат по возрастанию
    std::sort(X, X + sz);

    //вводим новую переменную для индекса
    int sz2 = 1;
    //Убираем повторяющиеся элементы
    //и находим индекс последнего элемента
    for (int i = 1; i < sz; ++i)
    {
        if (X[i] != X[sz2 - 1])
        {
            X[sz2] = X[i];
            ++sz2;
        }
    }

    sz = sz2;
    //Заполнение массива white значениями true
    memset(white, true, sizeof(white));

    //проходим по всем перекрашиваниям
    for (int i = 0; i < N; ++i)
    {
        int lo = 0, hi = sz - 1, mi;

        //ищем минимальную начальную координату
        while (lo < hi) {
            mi = (lo + hi) / 2;

            if (X[mi] < a[i])
                lo = mi + 1;
            else
                hi = mi;
        }

        int pos = lo;
        //определяем цвет перекрашивания
        bool c = (color[i] == 'w' ? true : false);

        //Заполняем массив для белого перекрашивания логическими значениями до конца определенного отрезка
        while (X[pos] != b[i]) {
            white[pos] = c;
            ++pos;
        }
    }

    int ans = 0, x = 0, y = 0;
    int cur = 0, cur_x = 0;
    //проходим по массиву координат до предпоследнего
    for (int i = 0; i + 1 < sz; ++i)
    {
        //Если отрезок белый
        if (white[i])
        {
            //то присваиваем переменной cur_x координату начала
            if (cur == 0)
                cur_x = X[i];
            //а в переменную cur прибавляем длину данного интервала
            //(до следующей координаты
            cur += X[i + 1] - X[i];

            //проверяем является ли эта длина максимальной
            //и если это так записываем координаты этого белого интервала
            if (cur > ans) {
                ans = cur;
                x = cur_x;
                y = X[i + 1];
            }
        }
        else cur = 0;
    }

    std::cout << x << " " << y;

    return 0;
}

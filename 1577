#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>

//максимальная длина строки
const int MAXN = 2001;

//модуль(из условия)
const int MOD = (int)1e9 + 7;

//массив для 1 строки
char A[MAXN];
//массив для 2 строки
char B[MAXN];
//таблица, в которой содержится информация о длине универсального пароля
short int dp[MAXN][MAXN];
//таблица в которой содержится информация о количестве паролей минимальной длины
long long ways[MAXN][MAXN];

int main()
{
	//вводим строки
	scanf("%s", A + 1);
	scanf("%s", B + 1);

	//определяем их длину
	int lenA = strlen(A + 1);
	int lenB = strlen(B + 1);

	//изначально для длины сттроки, равной нулю
	//устанавливается количество символов равное длине другой строки
	//а количество способов равно единице
	dp[0][0] = 0;
	ways[0][0] = 1;

	//в первом столбце массива dp содержатся индексы первой строки
	//а в первой строке - второй
	//количество способов замены пока и в 1 строке и в 1 столбце равно единицам
	for (int i = 1; i <= lenA; i++)
	{
		dp[i][0] = i;
		ways[i][0] = 1;
	}

	for (int j = 1; j <= lenB; j++)
	{
		dp[0][j] = j;
		ways[0][j] = 1;
	}

	//проходим по таблицам
	for (int i = 1; i <= lenA; i++)
		for (int j = 1; j <= lenB; j++)
		{
			//если элементы строк равны
			//то диагональный элемент матрицы равен предыдущему диагональному
			//(при первом проходе это элемент с индексами (0;0) и значением в ячейке равным 0
			//для массива dp и равным 1 для массива ways
			if (A[i] == B[j])
			{
				dp[i][j] = dp[i - 1][j - 1] + 1;
				ways[i][j] = ways[i - 1][j - 1];
			}
			//если же элементы не равны, то мы записываем минимальный из предыдущих пибавляя единицу
			else
			{
				dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;
				//если в предыдущей строке(не меняя столбца) элемент оказался меньше, чем
				//в предыдущем столбце(не меняя строки), то количество способов суммируется
				//с тем значением, что в предыдущей строке
				//иначе суммируется со значением в предыдущем столбце
				//если же они равны, то суммирование происходит дважды
				if (dp[i - 1][j] <= dp[i][j - 1])
					ways[i][j] = (ways[i][j] + ways[i - 1][j]) % MOD;
				if (dp[i][j - 1] <= dp[i - 1][j])
					ways[i][j] = (ways[i][j] + ways[i][j - 1]) % MOD;
			}
		}

	std::cout << ways[lenA][lenB] << std::endl;

	return 0;
}
